'use client'

import { useState, useEffect, useCallback, useRef } from 'react'
import { useSelector } from 'react-redux'
import { RootState } from '@/store'
import { apiService } from '@/lib/api-service'
import { useUnifiedSocketContext } from '@/components/providers/UnifiedSocketProvider'

export type VideoCard = {
  id: string
  videoId: string
  title: string
  status: 'processing' | 'ready' | 'completed' | 'success' | 'failed'
  createdAt: string
  updatedAt: string
  videoUrl?: string
  downloadUrl?: string | null
  autoGenerated?: boolean
  metadata?: {
    duration?: number
    size?: number
    format?: string
  }
  error?: string
  socialMediaCaptions?: {
    instagram_caption?: string
    facebook_caption?: string
    linkedin_caption?: string
    twitter_caption?: string
    tiktok_caption?: string
    youtube_caption?: string
  }
}

export function useVideoGallery() {
  const [videos, setVideos] = useState<VideoCard[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const accessToken = useSelector((state: RootState) => state.user.accessToken)
  const currentUser = useSelector((state: RootState) => state.user.user)
  const { latestVideoUpdate } = useUnifiedSocketContext()

  const fetchVideosRef = useRef<(() => Promise<void>) | null>(null)

  const fetchVideos = useCallback(async () => {
    if (!accessToken) {
      setError('Authentication required')
      setLoading(false)
      return
    }

    try {
      setLoading(true)
      setError(null)

      const result = await apiService.getVideoGallery()

      if (result.success && result.data) {
        const mappedVideos = result.data.videos.map((video: any) => ({
          ...video,
          videoUrl: video.videoUrl || video.downloadUrl || ''
        }))
        setVideos(mappedVideos)
      } else {
        throw new Error(result.message || 'Failed to fetch videos')
      }
    } catch (err: any) {
      const errorMessage = err.message || 'Failed to fetch videos'
      setError(errorMessage)
    } finally {
      setLoading(false)
    }
  }, [accessToken])

  useEffect(() => {
    fetchVideosRef.current = fetchVideos
  }, [fetchVideos])

  useEffect(() => {
    fetchVideosRef.current?.()
  }, [accessToken])

  // Handle video completion - refresh gallery when video is done
  useEffect(() => {
    if (!currentUser || !latestVideoUpdate) return

    const { status } = latestVideoUpdate
    console.log('ðŸŽ¬ Gallery received video update:', { status, message: latestVideoUpdate.message })

    if (status === 'completed' || status === 'success') {
      console.log('ðŸŽ¬ Video completed successfully, refreshing gallery...')
      const timeoutId = setTimeout(() => {
        fetchVideosRef.current?.()
      }, 1000)

      return () => clearTimeout(timeoutId)
    }
  }, [latestVideoUpdate, currentUser])

  const isVideoProcessing = latestVideoUpdate &&
    (latestVideoUpdate.status === 'processing' || latestVideoUpdate.status === 'pending')

  return {
    videos,
    loading,
    error,
    fetchVideos,
    isVideoProcessing,
    latestVideoUpdate
  }
}

